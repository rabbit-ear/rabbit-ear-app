import type { Box, FOLD } from "rabbit-ear/types.js";
import { includeS } from "rabbit-ear/math/compare.js";
import { intersectLineLine } from "rabbit-ear/math/intersect.js";
import { filterKeysWithPrefix, filterKeysWithSuffix, getDimensionQuick } from "rabbit-ear/fold/spec.js";
import { subgraphExclusive } from "rabbit-ear/graph/subgraph.js";

export type FOLDSelection = {
  vertices?: number[];
  edges?: number[];
  faces?: number[];
};

const pointInRect2 = (p: [number, number], rect: Box) =>
  p[0] > rect.min[0] &&
  p[0] < rect.max[0] &&
  p[1] > rect.min[1] &&
  p[1] < rect.max[1];

const pointInRect3 = (p: [number, number, number], rect: Box) =>
  p[0] > rect.min[0] &&
  p[0] < rect.max[0] &&
  p[1] > rect.min[1] &&
  p[1] < rect.max[1] &&
  p[2] > rect.min[2] &&
  p[2] < rect.max[2];

// the largest valid subcomplex generated by a given vertex set
// (all edges/faces whose vertices are fully included).
export const strictSelectComponents = (graph: FOLD, rect: Box): FOLDSelection => {
  const dimension = getDimensionQuick(graph);
  const verticesLookup = dimension === 3
    ? graph.vertices_coords?.map((p) => pointInRect3(p as [number, number, number], rect))
    : graph.vertices_coords?.map((p) => pointInRect2(p as [number, number], rect))
  if (!verticesLookup) { return {}; }
  const vertices = (verticesLookup ?? [])
    .map((sel, i) => (sel ? i : undefined))
    .filter((a) => a !== undefined);
  const edgesLookup = (graph.edges_vertices ?? [])
    .map(vertices => vertices
      .map(v => verticesLookup[v])
      .reduce((a, b) => a && b, true));
  const edges = (edgesLookup ?? [])
    .map((sel, i) => (sel ? i : undefined))
    .filter((a) => a !== undefined);
  const facesLookup = (graph.faces_vertices ?? [])
    .map(vertices => vertices
      .map(v => verticesLookup[v])
      .reduce((a, b) => a && b, true));
  const faces = (facesLookup ?? [])
    .map((sel, i) => (sel ? i : undefined))
    .filter((a) => a !== undefined);
  return { vertices, edges, faces };
};

const closedSubcomplex = (graph: FOLD, selection: FOLDSelection): FOLDSelection => {
  const lookup: {
    // vertices: { [key: string]: boolean },
    // edges: { [key: string]: boolean },
    // faces: { [key: string]: boolean },
    vertices: boolean[],
    edges: boolean[],
    faces: boolean[],
  } = { vertices: [], edges: [], faces: [] };
  // add vertices to the lookup table, all vertices from
  // vertices, edges' edges_vertices, and faces' faces_vertices.
  selection.faces?.forEach((f) => {
    lookup.faces[f] = true;
  });
  if (graph.faces_vertices) {
    selection.faces?.forEach((face) =>
      graph.faces_vertices![face].forEach((v) => {
        lookup.vertices[v] = true;
      }));
  }
  if (graph.faces_edges) {
    selection.faces?.forEach((face) =>
      graph.faces_edges![face].forEach((e) => {
        lookup.edges[e] = true;
      }));
  }

  selection.edges?.forEach((e) => {
    lookup.edges[e] = true;
  });
  if (graph.edges_vertices) {
    selection.edges?.forEach((edge) =>
      graph.edges_vertices![edge]?.forEach((v) => {
        lookup.vertices[v] = true;
      }));
  }

  selection.vertices?.forEach((v) => {
    lookup.vertices[v] = true;
  });

  const vertices = (lookup.vertices ?? [])
    .map((sel, i) => (sel ? i : undefined))
    .filter((a) => a !== undefined);
  const edges = (lookup.edges ?? [])
    .map((sel, i) => (sel ? i : undefined))
    .filter((a) => a !== undefined);
  const faces = (lookup.faces ?? [])
    .map((sel, i) => (sel ? i : undefined))
    .filter((a) => a !== undefined);
  return { vertices, edges, faces };
};

export const strictSubcomplex = (graph: FOLD, selection: FOLDSelection): FOLD => {
  const closedSelection = closedSubcomplex(graph, selection);

  console.log(closedSelection);

  return subgraphExclusive(graph, closedSelection);
};

